import React, { useState, useEffect } from 'react';
import styled from 'styled-components';
import { 
  getAllBookings, 
  updateBooking, 
  deleteBooking,
  getBookingsByBike,
  getBookingsByDateRange,
  calculateBookingDuration,
  getRevenueByPeriod
} from '../services/bookingService';
import { getBikes } from '../services/bikeService';
import { getUsers } from '../services/userService';
import { format } from 'date-fns';
import { db } from '../firebase';
import { 
  collection, 
  query, 
  orderBy, 
  onSnapshot,
  doc,
  getDocs
} from 'firebase/firestore';

// Pine green and gray theme colors consistent with app
const colors = {
  pineGreen: '#1D3C34',
  lightPineGreen: '#2D5A4C',
  darkGray: '#333333',
  mediumGray: '#666666',
  lightGray: '#f2f2f2',
  white: '#ffffff',
  red: '#d32f2f',
  amber: '#ffc107',
  green: '#4caf50',
  blue: '#2196f3',
  lightBlue: '#e3f2fd',
  lightGreen: '#e8f5e9',
  lightRed: '#ffebee',
  lightAmber: '#fff8e1'
};

// Container styled component
const Container = styled.div`
  width: 100%;
`;

// Use all the other styled components here like:
// PageHeader, PageTitle, etc...

const BookingManagement = () => {
  const [bookings, setBookings] = useState([]);
  const [filteredBookings, setFilteredBookings] = useState([]);
  const [bikes, setBikes] = useState([]);
  const [loading, setLoading] = useState(true);
  const [statusFilter, setStatusFilter] = useState('all');
  const [bikeFilter, setBikeFilter] = useState('all');
  const [bookingTypeFilter, setBookingTypeFilter] = useState('all');
  const [searchTerm, setSearchTerm] = useState('');
  const [startDateFilter, setStartDateFilter] = useState('');
  const [endDateFilter, setEndDateFilter] = useState('');
  const [currentPage, setCurrentPage] = useState(1);
  const [updating, setUpdating] = useState(false);
  const [sortBy, setSortBy] = useState('startDate');
  const [sortDirection, setSortDirection] = useState('desc');
  const [selectedBooking, setSelectedBooking] = useState(null);
  const [showDetailsModal, setShowDetailsModal] = useState(false);
  const [activeTab, setActiveTab] = useState('details');
  const [revenueData, setRevenueData] = useState({
    day: { totalRevenue: 0, bookings: 0 },
    week: { totalRevenue: 0, bookings: 0 },
    month: { totalRevenue: 0, bookings: 0 }
  });
  const [bikeBookingsMap, setBikeBookingsMap] = useState({});
  const [selectedBikeId, setSelectedBikeId] = useState(null);
  const [showAllBikesView, setShowAllBikesView] = useState(true);
  
  const bookingsPerPage = 10;

  // State to track real-time updates
  const [realTimeEnabled, setRealTimeEnabled] = useState(true);

  // Helper function to load bookings without real-time updates
  const loadBookingsOnce = async (bikesData, usersData) => {
    try {
      const bookingsData = await getAllBookings();
      
      // Enhance booking data with bike and user information
      const enhancedBookings = bookingsData.map(booking => {
        let enhancedBooking = { ...booking };
        
        // Add bike information if missing
        if (!booking.bikeName) {
          const matchingBike = bikesData.find(bike => bike.id === booking.bikeId);
          if (matchingBike) {
            enhancedBooking = {
              ...enhancedBooking,
              bikeName: matchingBike.name || 'Unknown Bike',
              bikeType: matchingBike.type || '',
              bikeImageUrl: matchingBike.imageUrl || ''
            };
          }
        }
        
        // Add user fullName if missing
        if (!booking.fullName) {
          const matchingUser = usersData.find(user => user.id === booking.userId);
          if (matchingUser) {
            enhancedBooking = {
              ...enhancedBooking,
              fullName: matchingUser.fullName || matchingUser.displayName || booking.userName
            };
          }
        }
        
        return enhancedBooking;
      });
      
      setBookings(enhancedBookings);
      setFilteredBookings(enhancedBookings);
      
      // Group bookings by bike
      const groupedBookings = {};
      bikesData.forEach(bike => {
        groupedBookings[bike.id] = enhancedBookings.filter(booking => booking.bikeId === bike.id);
      });
      setBikeBookingsMap(groupedBookings);
      
      setLoading(false);
    } catch (error) {
      console.error('Error loading bookings:', error);
      setLoading(false);
    }
  };

  // Clear all filters
  const clearFilters = () => {
    setStatusFilter('all');
    setBikeFilter('all');
    setBookingTypeFilter('all');
    setSearchTerm('');
    setStartDateFilter('');
    setEndDateFilter('');
    setSortBy('startDate');
    setSortDirection('desc');
  };

  // Remove individual filter
  const removeFilter = (filterType) => {
    switch (filterType) {
      case 'status':
        setStatusFilter('all');
        break;
      case 'bike':
        setBikeFilter('all');
        break;
      case 'type':
        setBookingTypeFilter('all');
        break;
      case 'search':
        setSearchTerm('');
        break;
      case 'dateRange':
        setStartDateFilter('');
        setEndDateFilter('');
        break;
      default:
        break;
    }
  };

  // Get active filters for filter tags
  const getActiveFilters = () => {
    const filters = [];
    
    if (statusFilter !== 'all') {
      filters.push({
        type: 'status',
        label: `Status: ${statusFilter}`,
      });
    }
    
    if (bikeFilter !== 'all') {
      const bike = bikes.find(b => b.id === bikeFilter);
      filters.push({
        type: 'bike',
        label: `Bike: ${bike ? bike.name : bikeFilter}`,
      });
    }
    
    if (bookingTypeFilter !== 'all') {
      filters.push({
        type: 'type',
        label: `Type: ${bookingTypeFilter}`,
      });
    }
    
    if (searchTerm) {
      filters.push({
        type: 'search',
        label: `Search: ${searchTerm}`,
      });
    }
    
    if (startDateFilter && endDateFilter) {
      filters.push({
        type: 'dateRange',
        label: `Date: ${startDateFilter} to ${endDateFilter}`,
      });
    }
    
    return filters;
  };

  // Initial data loading
  useEffect(() => {
    // Load bookings, bikes, and revenue data
    const loadData = async () => {
      try {
        setLoading(true);
        
        // Load bikes and users in parallel
        const [bikesData, usersData] = await Promise.all([
          getBikes(),
          getUsers()
        ]);
        
        setBikes(bikesData);
        
        // Set up real-time listener for bookings if enabled
        if (realTimeEnabled) {
          try {
            // Use collectionGroup query to get bookings from all locations
            const bookingsRef = collection(db, "bookings");
            const userBookingsGroupRef = db.collectionGroup("bookings");
            const bikeBookingsGroupRef = db.collectionGroup("bookings");
            
            // Create a query that will include all bookings
            const bookingsQuery = query(bookingsRef);
            const bookingsSnapshot = await getDocs(bookingsQuery);
            
            console.log("Main bookings collection! Documents count:", bookingsSnapshot.docs.length);
            
            // Process bookings data from the main collection
            const bookingsData = bookingsSnapshot.docs.map(doc => {
              const data = doc.data();
              
              // Standardize date formats
              let startDate = data.startDate;
              let endDate = data.endDate;
              
              // Handle Firestore Timestamp
              if (startDate && typeof startDate.toDate === 'function') {
                startDate = startDate.toDate();
              } 
              // Handle ISO string
              else if (startDate && typeof startDate === 'string') {
                startDate = new Date(startDate);
              }
              // Handle numeric timestamp
              else if (startDate && typeof startDate === 'number') {
                startDate = new Date(startDate);
              }
              
              // Do the same for endDate
              if (endDate && typeof endDate.toDate === 'function') {
                endDate = endDate.toDate();
              }
              else if (endDate && typeof endDate === 'string') {
                endDate = new Date(endDate);
              }
              else if (endDate && typeof endDate === 'number') {
                endDate = new Date(endDate);
              }
              
              return {
                id: doc.id,
                ...data,
                startDate,
                endDate
              };
            });
            
            // Also get bookings from user subcollections using collectionGroup
            const userBookingsGroupQuery = query(userBookingsGroupRef);
            const userBookingsSnapshot = await getDocs(userBookingsGroupQuery);
            
            console.log("User bookings from collectionGroup query! Documents count:", userBookingsSnapshot.docs.length);
            
            // Process bookings data from user subcollections
            const userBookingsData = userBookingsSnapshot.docs.map(doc => {
              const data = doc.data();
              console.log(`Processing user booking ${doc.id}:`, data);
              
              // Standardize date formats
              let startDate = data.startDate;
              let endDate = data.endDate;
              
              // Handle Firestore Timestamp
              if (startDate && typeof startDate.toDate === 'function') {
                startDate = startDate.toDate();
              } 
              // Handle ISO string
              else if (startDate && typeof startDate === 'string') {
                startDate = new Date(startDate);
              }
              // Handle numeric timestamp
              else if (startDate && typeof startDate === 'number') {
                startDate = new Date(startDate);
              }
              
              // Do the same for endDate
              if (endDate && typeof endDate.toDate === 'function') {
                endDate = endDate.toDate();
              }
              else if (endDate && typeof endDate === 'string') {
                endDate = new Date(endDate);
              }
              else if (endDate && typeof endDate === 'number') {
                endDate = new Date(endDate);
              }
              
              return {
                id: doc.id,
                ...data,
                startDate,
                endDate
              };
            });
            
            // Also get bookings from the bike subcollections using collectionGroup
            const bikeBookingsGroupQuery = query(bikeBookingsGroupRef);
            const bikeBookingsSnapshot = await getDocs(bikeBookingsGroupQuery);
            
            console.log("Bike bookings from collectionGroup query! Documents count:", bikeBookingsSnapshot.docs.length);
            
            // Process bookings data from bike subcollections
            const bikeBookingsData = bikeBookingsSnapshot.docs.map(doc => {
              const data = doc.data();
              console.log(`Processing bike booking ${doc.id}:`, data);
              
              // Standardize date formats
              let startDate = data.startDate;
              let endDate = data.endDate;
              
              // Handle Firestore Timestamp
              if (startDate && typeof startDate.toDate === 'function') {
                startDate = startDate.toDate();
              } 
              // Handle ISO string
              else if (startDate && typeof startDate === 'string') {
                startDate = new Date(startDate);
              }
              // Handle numeric timestamp
              else if (startDate && typeof startDate === 'number') {
                startDate = new Date(startDate);
              }
              
              // Do the same for endDate
              if (endDate && typeof endDate.toDate === 'function') {
                endDate = endDate.toDate();
              }
              else if (endDate && typeof endDate === 'string') {
                endDate = new Date(endDate);
              }
              else if (endDate && typeof endDate === 'number') {
                endDate = new Date(endDate);
              }
              
              return {
                id: doc.id,
                ...data,
                startDate,
                endDate
              };
            });
            
            // Merge all bookings sources, avoiding duplicates
            const mergedBookings = [...bookingsData];
            
            // Add user bookings that don't already exist in the main collection
            userBookingsData.forEach(userBooking => {
              if (!mergedBookings.some(booking => booking.id === userBooking.id)) {
                mergedBookings.push(userBooking);
              }
            });
            
            // Add bike bookings that don't already exist in the merged collection
            bikeBookingsData.forEach(bikeBooking => {
              if (!mergedBookings.some(booking => booking.id === bikeBooking.id)) {
                mergedBookings.push(bikeBooking);
              }
            });
            
            console.log("Total unique bookings after all merges:", mergedBookings.length);
            
            // Enhance booking data with bike and user information
            const enhancedBookings = mergedBookings.map(booking => {
              let enhancedBooking = { ...booking };
              
              // Add bike information if missing
              if (!booking.bikeName) {
                const matchingBike = bikesData.find(bike => bike.id === booking.bikeId);
                if (matchingBike) {
                  enhancedBooking = {
                    ...enhancedBooking,
                    bikeName: matchingBike.name || 'Unknown Bike',
                    bikeType: matchingBike.type || '',
                    bikeImageUrl: matchingBike.imageUrl || ''
                  };
                }
              }
              
              // Add user fullName if missing
              if (!booking.fullName) {
                const matchingUser = usersData.find(user => user.id === booking.userId);
                if (matchingUser) {
                  enhancedBooking = {
                    ...enhancedBooking,
                    fullName: matchingUser.fullName || matchingUser.displayName || booking.userName
                  };
                }
              }
              
              return enhancedBooking;
            });
            
            // Update state with the real-time data
            setBookings(enhancedBookings);
            setFilteredBookings(enhancedBookings);
            
            // Group bookings by bike
            const groupedBookings = {};
            bikesData.forEach(bike => {
              groupedBookings[bike.id] = enhancedBookings.filter(booking => booking.bikeId === bike.id);
            });
            setBikeBookingsMap(groupedBookings);

            // If we have a selected booking, update its data too
            if (selectedBooking) {
              const updatedSelectedBooking = enhancedBookings.find(booking => booking.id === selectedBooking.id);
              if (updatedSelectedBooking) {
                setSelectedBooking(updatedSelectedBooking);
              }
            }
            
            setLoading(false);
          } catch (error) {
            console.error("Error processing real-time bookings:", error);
            setLoading(false);
            // Fall back to regular fetch if real-time listener fails
            setRealTimeEnabled(false);
            loadBookingsOnce(bikesData, usersData);
          }
        } else {
          // If real-time is disabled, load bookings once
          await loadBookingsOnce(bikesData, usersData);
        }
        
        // Load revenue data
        const [dayRevenue, weekRevenue, monthRevenue] = await Promise.all([
          getRevenueByPeriod('day'),
          getRevenueByPeriod('week'),
          getRevenueByPeriod('month')
        ]);
        
        setRevenueData({
          day: dayRevenue,
          week: weekRevenue,
          month: monthRevenue
        });
      } catch (error) {
        console.error('Error loading booking data:', error);
        setLoading(false);
      }
    };
    
    loadData();
  }, [realTimeEnabled, selectedBooking]);

  // Return loading state or actual UI
  return (
    <Container>
      <h1>Booking Management</h1>
      {/* Rest of the UI components */}
    </Container>
  );
};

export default BookingManagement; 